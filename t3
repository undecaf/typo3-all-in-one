#!/bin/bash

#
# Controls execution and configuration of TYPO3 in a container
# ============================================================
#
# For help, run this script without any arguments.
#
# Copyright F. Kasper <fkasper@modus-operandi.at> 2019
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#

# Constants
T3_IMAGE=undecaf/typo3-in-a-box
T3_ROOTDIR=/var/www/localhost
T3_DATADIR=/var/lib/typo3-db
CERT_BASENAME=/etc/ssl/apache2/custom
FILE_LIMIT='nofile=10000:15000'
RE_CONT_ENV='TIMEZONE|LANG|MODE|COMPOSER_EXCLUDE|PHP_.+'

# Bypass aliases
AWK=$(which awk)
BASENAME=$(which basename)
BINDFS=$(which bindfs 2>/dev/null)
CAT=$(which cat)
DF=$(which df)
DIRNAME=$(which dirname)
GREP=$(which grep)
HOSTNAME=$(which hostname)
LS=$(which ls)
MKDIR=$(which mkdir)
PRINTENV=$(which printenv)
PS=$(which ps)
SLEEP=$(which sleep)
STAT=$(which stat)
SUDO=$(which sudo)
UNAME=$(which uname)


# --------------------------------------------------------------------------

# Returns success if this script runs under macOS (Darwin).
#
test_macos() {
    [ "$($UNAME)" = 'Darwin' ]
}


# --------------------------------------------------------------------------

# Returns success if this script runs under the specified shell.
#
# Arguments:
#   $1  basename of shell command
#
test_shell() {
    [ "$(basename $($PS -p $$ -o comm=))" = "$1" ]
}


# --------------------------------------------------------------------------

# Converts this script to Zsh syntax and echoes the result to stdout.
#
# DO NOT USE ARRAYS EXCEPT FOR BASH_REMATCH[] as Zsh array indices
# start at 1.
#
# DO NOT 'setopt KSH_ARRAYS', this will break regex group indices.
#
convert_to_zsh() {
    # Rename 'BASH_REMATCH' to 'match'
    sed -E \
        -e 's/BASH_REMATCH/match/' \
        "$0"
}


# --------------------------------------------------------------------------

# Restart this script under Zsh if running in (outdated) Bash in macOS
test_macos && test_shell 'bash' && exec zsh <(convert_to_zsh) "$@"

# Set Bash and Zsh options for compatibility
if test_shell 'zsh'; then
    # Split parameters on whitespace
    setopt SH_WORD_SPLIT

    # Allow '@()' for parenthesized globbing expressions
    setopt KSH_GLOB

else
    # Allow '@()' for parenthesized globbing expressions
    shopt -s extglob
fi


# ------------ What follows may not be parseable by macOS Bash -------------

# Shows $USAGE and an optional error message at stdout or stderr
# and exits with exit code 0 or 1, respectively.
#
# Arguments:
#   $1  (optional) error message: if specified then it is printed, and all
#       output is sent to stderr; otherwise $USAGE goes to stdout.
#
# Environment:
#   $USAGE usage information; how to preserve linefeeds in $USAGE:
#       USAGE=$(cat <<EOT
#           ... multiline text ...
#       EOT
#       )
#
usage() {
    local SCRIPT=$($BASENAME $0)
    local REDIR=
    local EXIT_CODE=0

    if [ -n "$1" ]; then
        $CAT >&2 <<- EOT

*** $1 ***
EOT
        REDIR=">&2"
        EXIT_CODE=1
    fi

    eval 'echo "$USAGE" '$REDIR
    exit $EXIT_CODE
}


# --------------------------------------------------------------------------

# Shows a message at stderr and exits with the specified return status (or
# with 1).
#
# Arguments:
#   $1  error message
#   $2  (optional) return code, defaults to 1
#
err_exit() {
    echo '*** '"$1"' ***' >&2
    exit ${2:-1}
}


# --------------------------------------------------------------------------

# Returns success if the argument contains a '/'.
#
# Arguments:
#   $1  string to test
#
test_path() {
    local RE
    RE='.+/.+'
    [[ "$1" =~ $RE ]]
}


# --------------------------------------------------------------------------

# If the argument is a path, returns success only if at least the parent
# exists and if it is an empty directory.
#
# Arguments:
#   $1  path of a working directory to bind-mount, or a volume name
#
# Calls:
#   test_path
#
test_dir() {
    if test_path "$1"; then
        # At least the parent directory must exist
        [ -d "$($DIRNAME "$1")" ] || usage "Working directory '$1' does not have a parent"

        # Mount point must be an empty directory
        [ -n "$($LS -A "$1" 2>/dev/null)" ] && usage "Working directory path '$1' is not an empty directory"
    fi
}


# --------------------------------------------------------------------------

# Canonicalizes a path and echoes it to stdout.
#
# Arguments:
#   $1  path to canonicalize
#
canonicalize() {
    (
        cd "$1"
        pwd -P
    )
}


# --------------------------------------------------------------------------

# Autocompletes a string and echoes it to stdout. Echoes the original
# string if autocompletion could not be achieved.
#
# Arguments:
#   $1  string to autocomplete
#   $2, $3, ...
#       autocompleted strings
#
autocomplete() {
    local MATCHES=0
    local COMPLETED
    local ARG="$1"
    shift
    for AC in "$@"; do
        if [ "${AC##$ARG}" != "$AC" ]; then
            COMPLETED=$AC
            MATCHES=$((MATCHES+1))
        fi
    done

    # Consider autocompleted only if the abbreviation was unambiguous
    [ $MATCHES -eq 1 ] && echo "$COMPLETED" || echo "$ARG"
}


# --------------------------------------------------------------------------

# Returns success if the specified container exists.
#
# Arguments:
#   $1  container name
#
# Environment:
#   $T3_ENGINE
test_container() {
    $T3_ENGINE container inspect $1 &>/dev/null
}


# --------------------------------------------------------------------------

# Runs/execs the selected container engine with the given arguments.
# If T3_DEBUG is non-empty then the run command is echoed to stdout,
# and engine messages sent to stdout and stderr are visible at the
# console. Otherwise, only stderr is displayed at the console.
#
# Arguments:
#   $1, $2, ...
#       arguments to be passed to the container engine
#
# Environment:
#   $T3_ENGINE
#   $T3_DEBUG
#
run_engine() {
    if [ -n "$T3_DEBUG" ]; then
        echo "$T3_ENGINE $@"
        $T3_ENGINE "$@"
    else
        $T3_ENGINE "$@" >/dev/null
    fi
}

exec_engine() {
    [ -n "$T3_DEBUG" ] && echo "$T3_ENGINE $@"
    exec $T3_ENGINE "$@"
}


# --------------------------------------------------------------------------

# Bind-mounts a working directory to a container volume so that files and
# directories of that volume appear to be owned by the current user.
# Returns failure if no suitable path was given.
#
# Arguments:
#   $1  name of container volume
#   $2  working directory path
#
# Calls:
#   test_path
#   err_exit
#
# Environment:
#   $T3_ENGINE
#   $MP_FORMAT
#   $SUDO_PREFIX
#
mount_volume() {
    if test_path "$2"; then
        if [ -z "$BINDFS" ]; then
            unset USAGE
            usage "bindfs not installed, see https://bindfs.org/ for information"
        fi

        local BIND_MP
        local VOL_MP
        local VOL_UID
        local VOL_GID
        local FORMAT_OPT

        # Locate the volume mount point of the container engine
        VOL_MP=$($T3_ENGINE volume inspect --format "$MP_FORMAT" "$1") \
            || err_exit '*** '"Volume '$1' not found"' ***'

        # Acquire sudo authorization for what follows
        $SUDO --prompt '*** sudo authorization is required for bind-mounting working directories: ' --validate

        # Determine UID and GID of the volume owner (options differ between Linux and macOS)
        test_macos && FORMAT_OPT=-f || FORMAT_OPT=--format
        VOL_UID=$($SUDO_PREFIX $STAT $FORMAT_OPT '%u' $VOL_MP 2>/dev/null)
        VOL_GID=$($SUDO_PREFIX $STAT $FORMAT_OPT '%g' $VOL_MP 2>/dev/null)

        # Create the directory if necessary
        $MKDIR -p "$2"
        BIND_MP=$(canonicalize "$2")

        $SUDO $BINDFS \
            --map=$VOL_UID/$(id -u):@$VOL_GID/@$(id -g) \
            $VOL_MP \
            "$BIND_MP" \
        && echo "Working directory '$BIND_MP' bind-mounted to volume '$1'"

    else
        return 1
    fi
}


# --------------------------------------------------------------------------

# Unmounts whatever may be bind-mounted to a container volume mount point.
# Does nothing if nothing is mounted there.
#
# Arguments:
#   $1  name of container volume
#
# Calls:
#   unmount_workdir
#
# Environment:
#   $T3_ENGINE
#   $MP_FORMAT
#
unmount_volume() {
    # Find the container volume mountpoint
    local VOL_MP
    local LINE
    local RE

    VOL_MP=$($T3_ENGINE volume inspect --format=$MP_FORMAT "$1")
    # {{- ...}} and {{... -}} do no work here, therefore to trim:
    VOL_MP=$(echo $VOL_MP)

    # Find the directory bind-mounted to the container volume mountpoint
    RE='^/.+( +[0-9]+){4}% +(/.+)$'
    if LINE=$($DF -P | $GREP --fixed-string "$VOL_MP ") && [[ "$LINE" =~ $RE ]]; then
        unmount_workdir "$1" "${BASH_REMATCH[2]}"
    fi
}


# --------------------------------------------------------------------------

# Unmounts a working directory from wherever it may be mounted and returns
# the status of the unmount operation.
#
# Arguments:
#   $1  name of container volume
#   $2  working directory path
#
unmount_workdir() {
    $SUDO --prompt '*** sudo authorization is required for unmounting working directories: ' \
        umount "$2" \
    && echo "Working directory '$2' unmounted from volume '$1'"
}


# --------------------------------------------------------------------------

# Autocomplete command
CMD=$(autocomplete "$1" run stop logs env composer shell mount unmount)

shift
OPT_COUNT=$#

# Determine command
[ -n "$CMD" ] && MSG="Unknown or ambiguous command: '$CMD'" || MSG="Missing command"

case "$CMD" in

    # Run TYPO3 in a container, optionally with a database in an extra container
    run)
        USAGE=$($CAT <<EOT

Usage:
  $($BASENAME $0) run [option]... [--] [Docker/Podman 'create' option]...
  $($BASENAME $0) run [-h|--help]

Runs TYPO3 image 'undecaf/typo3-in-a-box' in a container in Docker or Podman.

Options (default values can be overridden by environment variables):

  --engine=ENGINE, -e ENGINE
      Container engine to use: 'docker', 'podman' (can be abbreviated) or an 
      absolute path to the engine executable.
      Default: \$T3_ENGINE, or 'podman' if installed, else 'docker'.

  --name=NAME, -n NAME
      Container name.
      Default: \$T3_NAME, or 'typo3'.

  --hostname=HOSTNAME, -H HOSTNAME
      Hostname assigned to the TYPO3 container and to Apache ServerName and
      ServerAdmin.
      Default: \$T3_HOSTNAME, or 'typo3.$($HOSTNAME)'.

  --tag=TAG, -T TAG
      Tag of image to run, consisting of TYPO3 version and build version,
      e.g. '8.7-1.3' or '9.5-latest'.
      Default: \$T3_TAG, or 'latest', i.e. the latest build for the most recent
      TYPO3 version.

  --pull, -u
      Pulls an up-to-date version of the image from the repository before
      running it.
      Default: \$T3_PULL, or not set.
      
  --composer-mode, -c
      If this option is present then Composer is responsible for installing/
      removing TYPO3 extensions. Otherwise, this is handled by the TYPO3
      Extension Manager.
      Default: \$T3_COMPOSER_MODE, or not set.
 
  --typo3-vol=VOLUME, -v VOLUME
      Either a volume name to be mapped to the TYPO3 root directory inside the
      container, or a working directory path (containing a '/').
      In the latter case, the directory basename is used as the volume name,
      and the directory is bind-mounted at that volume. Thus, volume content
      appears to be owned by the current user.
      Default: \$T3_ROOT, or 'typo3-root'.

  --typo3-ports=HTTP,HTTPS, -p HTTP,HTTPS
      Host interfaces (optional) and ports where to publish the TYPO3 HTTP port
      and the TYPO3 HTTPS port. If one of the parts is omitted then the respective
      port will not be published.
      Default: \$T3_PORTS, or '127.0.0.1:8080,127.0.0.1:8443'.

  --certfiles=PRIVATE-KEY,CERT, -k PRIVATE-KEY,CERT
      Private key file and certificate file for HTTPS, in PEM format and located
      at the host. If not specified then a self-signed certificate will be used
      for HTTPS connections.
      Default: \$T3_CERTFILES, or not set.

  --db-type=TYPE, -D TYPE
      Type of database to use: 'sqlite' or empty for SQLite, 'mariadb' for 
      MariaDB or 'postgresql' for PostgreSQL (can be abbreviated).
      Default: \$T3_DB_TYPE, or 'sqlite'.

  --db-vol=VOLUME, -V VOLUME
      Database volume name or working directory path (see '--typo3-root').
      Defaults: \$T3_DB_DATA, or 'typo3-data'.

  --db-port=PORT, -P PORT
      Host interface (optional) and port where to publish the database port;
      effective only for MariaDB and PostgreSQL.
      Defaults: \$T3_DB_PORT, or '127.0.0.1:3306' for MariaDB and '127.0.0.1:5432'
      for PostgreSQL.

  --env NAME=VALUE
      Sets the (initial) value of a container environment variable. Most variables
      can be changed afterwards by '$($BASENAME $0) env'. This option may appear
      multiple times.
      Defaults: \$T3_TIMEZONE, \$T3_LANG, \$T3_MODE, \$T3_COMPOSER_EXCLUDE,
                \$T3_PHP_..., \$T3_php_...
 
  --log, -l
      Streams the log output of the new TYPO3 instance to the console until 
      CTRL-C is typed.
      Default: \$T3_LOGS, or not set.
 
  --timestamps, -t
      Shows timestamps in the log output. Ignored if '--log' is not set.
      Default: \$T3_TIMESTAMPS, or not set.

  --debug, -d
      If this option is present then Docker/Podman commands and output appear
      at the console. Otherwise only 'stderr' is displayed.
      Warning: your database credentials will be visible at the console.
      Default: \$T3_DEBUG, or not set.
 
  --help, -h
      Displays this text and exits.

Additional options for the Docker/Podman 'create' command can be added after the options
described above. If necessary, '--' can be used to separate them from the $($BASENAME $0) options.
 
EOT
        )
        # No additional options required
        OPT_COUNT=1
        ;;


    # Stop and remove a TYPO3 container
    stop)
        USAGE=$($CAT <<EOT

Usage:
  $($BASENAME $0) stop [option]...
  $($BASENAME $0) stop [-h|--help]

Stops a TYPO3 container, optionally removes it and unmounts the working
directories of this container.

Options (default values can be overridden by environment variables):

  --engine=ENGINE, -e ENGINE
      Container engine being used: 'docker', 'podman' or an absolute path
      to the engine executable.
      Default: \$T3_ENGINE, or 'podman' if installed, else 'docker'.

  --name=NAME, -n NAME
      Same container name as specified for 't3 run'.
      Default: \$T3_NAME, or 'typo3'.
 
  --debug, -d
      If this option is present then Docker/Podman commands and output appear
      at the console. Otherwise only 'stderr' is displayed.
      Default: \$T3_DEBUG, or not set.
 
  --rm, -R
      Causes the TYPO3 container to be removed after is was stopped.
      This can also be used to remove a container that is not running.

  --help, -h
      Displays this text and exits.
 
EOT
        )
        # No additional options required
        OPT_COUNT=1
        ;;


    # Display the log output of a running TYPO3 container
    logs)
        USAGE=$($CAT <<EOT

Usage:
  $($BASENAME $0) logs [option]...
  $($BASENAME $0) logs [-h|--help]

Displays the log output of a running TYPO3 container.

Options (default values can be overridden by environment variables):

  --engine=ENGINE, -e ENGINE
      Container engine being used: 'docker', 'podman' or an absolute path
      to the engine executable.
      Default: \$T3_ENGINE, or 'podman' if installed, else 'docker'.

  --name=NAME, -n NAME
      Same container name as specified for 't3 run'.
      Default: \$T3_NAME, or 'typo3'.
 
  --follow, -f
      Streams the log output to the console until CTRL-C is typed.
      Default: \$T3_FOLLOW, or not set.
 
  --since=TIMESTAMP, -s TIMESTAMP
      Shows only log lines since a timestamp. This can be a Unix timestamp,
      a date formatted timestamp, or a Go duration string (e.g. 10m, 1h30m)
      computed relative to the client machine's time.
      Default: \$T3_SINCE, or not set.
 
  --tail=LINES, -l LINES
      Shows only that many lines from the end of the log, or all lines
      if 0.
      Default: \$T3_TAIL, or not set.

  --timestamps, -t
      Shows timestamps in the log output.
      Default: \$T3_TIMESTAMPS, or not set.

  --debug, -d
      If this option is present then Docker/Podman commands and output appear
      at the console. Otherwise only 'stderr' is displayed.
      Default: \$T3_DEBUG, or not set.

  --help, -h
      Displays this text and exits.
 
EOT
        )
        # No additional options required
        OPT_COUNT=1
        ;;


    # Change environment settings in a running TYPO3 container
    env)
        USAGE=$($CAT <<EOT

Usage:
  $($BASENAME $0) env [option]... [NAME=VALUE]...
  $($BASENAME $0) env [-h|--help]

Modifies the environment of a running TYPO3 container. Shows the
current environment if no NAME=VALUE pairs are given.

Options (default values can be overridden by environment variables):

  --engine=ENGINE, -e ENGINE
      Container engine being used: 'docker', 'podman' or an absolute path
      to the engine executable.
      Default: \$T3_ENGINE, or 'podman' if installed, else 'docker'.

  --name=NAME, -n NAME
      Same container name as specified for 't3 run'.
      Default: \$T3_NAME, or 'typo3'.
 
  --debug, -d
      If this option is present then Docker/Podman commands and output appear
      at the console. Otherwise only 'stderr' is displayed.
      Default: \$T3_DEBUG, or not set.

  --help, -h
      Displays this text and exits.
 
EOT
        )
        # No additional options required
        OPT_COUNT=1
        ;;


    # Run Composer in a running TYPO3 container
    composer)
        USAGE=$($CAT <<EOT

Usage:
  $($BASENAME $0) composer [option]... COMPOSER_CMD [Composer option]...
  $($BASENAME $0) composer [-h|--help]

Executes a Composer command inside of a running TYPO3 container.

Options (default values can be overridden by environment variables):

  --engine=ENGINE, -e ENGINE
      Container engine being used: 'docker', 'podman' or an absolute path
      to the engine executable.
      Default: \$T3_ENGINE, or 'podman' if installed, else 'docker'.

  --name=NAME, -n NAME
      Same container name as specified for 't3 run'.
      Default: \$T3_NAME, or 'typo3'.
 
  --debug, -d
      If this option is present then Docker/Podman commands and output appear
      at the console. Otherwise only 'stderr' is displayed.
      Default: \$T3_DEBUG, or not set.

  --help, -h
      Displays this text and exits.
 
EOT
        )
        ;;


    # Open an interactive Bash shell in a running TYPO3 container
    shell)
        USAGE=$($CAT <<EOT

Usage:
  $($BASENAME $0) shell [option]... [shell option]...
  $($BASENAME $0) shell [-h|--help]

Opens an interactive Bash shell in a running TYPO3 container.

Options (default values can be overridden by environment variables):

  --engine=ENGINE, -e ENGINE
      Container engine being used: 'docker', 'podman' or an absolute path
      to the engine executable.
      Default: \$T3_ENGINE, or 'podman' if installed, else 'docker'.

  --name=NAME, -n NAME
      Same container name as specified for 't3 run'.
      Default: \$T3_NAME, or 'typo3'.
 
  --debug, -d
      If this option is present then Docker/Podman commands and output appear
      at the console. Otherwise only 'stderr' is displayed.
      Default: \$T3_DEBUG, or not set.

  --help, -h
      Displays this text and exits.
 
EOT
        )
        # No additional options required
        OPT_COUNT=1
        ;;


    # Bind-mount a directory to a container volume
    mount)
        USAGE=$($CAT <<EOT

Usage:
  $($BASENAME $0) mount [option] WORK_DIR...
  $($BASENAME $0) mount [-h|--help]

Mounts one or more working directories to container volumes so that
the volumes appear to be owned by and can be managed by the current user.
The directories must be given as paths (containing '/'). The basenames
are used as volume names.

Equivalent to '$($BASENAME $0) run' options '-v' or '-V' with a working directory
path except that the container does not need to be running (it does not
even have to exist).

Options (default values can be overridden by environment variables):

  --engine=ENGINE, -e ENGINE
      Container engine being used: 'docker', 'podman' or an absolute path
      to the engine executable.
      Default: \$T3_ENGINE, or 'podman' if installed, else 'docker'.

  --help, -h
      Displays this text and exits.
 
EOT
        )
        ;;


    # Unmount a bind-mouted directory from a container volume
    unmount)
        USAGE=$($CAT <<EOT

Usage:
  $($BASENAME $0) unmount [option] WORK_DIR...
  $($BASENAME $0) unmount [-h|--help]

Unmounts one or more working directories from their container volumes.

Options (default values can be overridden by environment variables):

  --engine=ENGINE, -e ENGINE
      Container engine being used: 'docker', 'podman' or an absolute path
      to the engine executable.
      Default: \$T3_ENGINE, or 'podman' if installed, else 'docker'.

  --help, -h
      Displays this text and exits.
 
EOT
        )
        ;;


    # General help
    -h|--help)
        MSG=
        ;&


    # Unknown command
    *)
        USAGE=$($CAT <<EOT

Usage:
  $($BASENAME $0) COMMAND [option]... [argument]...
 
Available commands:
 
  run           Runs TYPO3 image 'undecaf/typo3-in-a-box' in a container in Docker or
                Podman.
 
  stop          Stops a running TYPO3 container.

  logs          Displays the log output of a running TYPO3 container.
 
  env           Modifies the environment of a running TYPO3 container.

  composer      When in Composer Mode, executes a Composer command inside a 
                running TYPO3 container.

  shell         Opens an interactive Bash shell in a running TYPO3 container.

  mount         Mounts a working directory to a container volume so that the
                volume appears to be owned and can be managed by the current user.

  unmount       Unmounts a working directory from the container volume.

  --help, -h    Displays this text and exits. Displays command-specific help if 
                combined with a command.

Each command can be abbreviated to an unambiguous verb, e.g. '$($BASENAME $0) stop' -> '$($BASENAME $0) st'
 
EOT
        )
        usage "$MSG"
        ;;
esac


# --------------------------------------------------------------------------

# Process command line options

# Default options, overridden by environment variables
T3_ENGINE=${T3_ENGINE:-$(which podman)} || T3_ENGINE=docker
T3_NAME=${T3_NAME:-typo3}
T3_HOSTNAME=${T3_HOSTNAME:-typo3.$($HOSTNAME)}

T3_TAG=${T3_TAG:-latest}
T3_ROOT=${T3_ROOT:-typo3-root}
T3_PORTS=${T3_PORTS:-127.0.0.1:8080,127.0.0.1:8443}

REMOVE_OPTION=
FOLLOW_OPTION=${T3_FOLLOW:+--follow}
SINCE_OPTION=${T3_SINCE:+--since=$T3_SINCE}
TIMESTAMPS_OPTION=${T3_TIMESTAMPS:+--timestamps}
TAIL_OPTION=${T3_TAIL:+--tail=$T3_TAIL}

while [ $# -gt 0 ]; do
    case $CMD:$1 in
        # Container engine
        *:@(-e|--engine))
            shift
            ;&

        *:--engine=*)
            T3_ENGINE="${1#--engine=}"  # basename or absolute path of an executable
            shift
            ;;

        # Pull (update) image before starting
        run:@(-u|--pull))
            T3_PULL=on
            shift
            ;;

        # Hostname
        run:@(-H|--hostname))
            shift
            ;&

        run:--hostname=*)
            T3_HOSTNAME="${1#--hostname=}"
            shift
            ;;

        # Container name
        @(run|stop|composer|shell|env):@(-n|--name))
            shift
            ;&

        @(run|stop|composer|shell|env):--name=*)
            T3_NAME="${1#--name=}"
            shift
            ;;

        # Composer Mode
        run:@(-c|--composer-mode))
            T3_COMPOSER_MODE=on
            shift
            ;;

        # Debug container engine commands
        @(run|stop|logs|composer|shell|env):@(-d|--debug))
            T3_DEBUG=on
            shift
            ;;

        # Image tag
        run:@(-T|--tag))
            shift
            ;&

        run:--tag=*)
            T3_TAG="${1#--tag=}"
            shift
            ;;

        # TYPO3 volume (volume name or path)
        # If a path is given then its basename is used as 
        # the name of a volume which is mounted at that path
        run:@(-v|--typo3-root))
            shift
            ;&

        run:--typo3-root=*)
            T3_ROOT="${1#--typo3-root=}"
            test_dir "$T3_ROOT"
            shift
            ;;

        # Database type
        run:@(-D|--db-type))
            shift
            ;&

        run:--db-type=*)
            T3_DB_TYPE="${1#--db-type=}"   # validated later
            shift
            ;;

        # Database volume (volume name or path)
        # If a path is given then its basename is used as 
        # the name of a volume which is mounted at that path
        run:@(-V|--db-data))
            shift
            ;&

        run:--db-data=*)
            T3_DB_DATA="${1#--db-data=}"
            test_dir "$T3_DB_DATA"
            shift
            ;;

        # TYPO3 HTTP and HTTPS interfaces and ports
        run:@(-p|--typo3-ports))
            shift
            ;&

        run:--typo3-ports=*)
            T3_PORTS="${1#--typo3-ports=}"
            shift
            ;;

        # Private key file and certificate file
        run:@(-k|--certfiles))
            shift
            ;&

        run:--certfiles=*)
            T3_CERTFILES="${1#--certfiles=}"
            shift
            ;;

        # Database port
        run:@(-P|--db-port))
            shift
            ;&

        run:--db-port=*)
            T3_DB_PORT="${1#--db-port=}"
            shift
            ;;

        # Container environment setting
        run:--env)
            shift
            ;&

        run:--env=*)
            ENV="${1#--env=}"
            RE='^('$RE_CONT_ENV')=(.*)$'
            [[ "$ENV" =~ $RE ]] || usage "Not a valid NAME=VALUE pair: '$ENV'"
            export T3_${BASH_REMATCH[1]}=${BASH_REMATCH[2]}
            shift
            ;;

        # Stream log output to console at startup
        run:@(-l|--log))
            T3_LOGS=on
            shift
            ;;

        # Show timestamps in log output
        @(run|logs):@(-t|--timestamps))
            TIMESTAMPS_OPTION='--timestamps'
            shift
            ;;

        # Stream log output to console
        logs:@(-f|--follow))
            FOLLOW_OPTION='--follow'
            shift
            ;;

        # Show only output since some timestamp
        logs:@(-s|--since))
            shift
            ;&

        logs:--since=*)
            SINCE_OPTION="--since=${1#--since=}"
            shift
            ;;

        # Show only a certain number of lines from the end of the log
        logs:@(-l|--tail))
            shift
            ;&

        logs:--tail=*)
            TAIL_OPTION="--tail=${1#--tail=}"
            shift
            ;;

        # Remove container(s) after being stopped
        stop:@(-R|--rm))
            REMOVE_OPTION='--rm'
            shift
            ;;

        # Help for selected command
        *:@(-h|--help))
            usage
            ;;

        # Separator from container engine options or mount/unmount directory
        *:--)
            shift
            break
            ;;

        # First unknown option or mount/unmount directory, keep remaining options in "$@"
        *)
            break
            ;;
    esac
done

# At least one (additional) argument must be present
[ $OPT_COUNT -eq 0 ] && usage 'No argument was found but at least one is required'


# --------------------------------------------------------------------------

# Set up the container environment
ENV_OPTIONS="--env T3_COMPOSER_MODE=$T3_COMPOSER_MODE "

# Determine container engine name
T3_ENGINE=$(autocomplete "$T3_ENGINE" docker podman)
[ -x "$(which $T3_ENGINE)" ] || usage "Container engine '$T3_ENGINE' not found"

T3_ENGINE=$(which $T3_ENGINE)
ENGINE_NAME=$($BASENAME $T3_ENGINE)

# Options that differ between container engines
case $ENGINE_NAME in
    docker)
        HOST_IP_ENV=
        MP_FORMAT='{{.Mountpoint}}'
        SUDO_PREFIX=$SUDO
        ;;

    podman)
        # hostname -I is not supported under macOS, therefore:
        HOST_IP_ENV="HOST_IP=$(ifconfig | $GREP 'inet ' | $GREP -v '127.0.0.1' | $AWK '{ print $2; }' | head -n 1)"
        ENV_OPTIONS="$ENV_OPTIONS \
            --env $HOST_IP_ENV"
        MP_FORMAT='{{.MountPoint}}'
        SUDO_PREFIX=
        ;;
esac

# Split into HTTP and HTTPS port and interface
RE='^((.+)?,(.+)?)?$'
[[ "$T3_PORTS" =~ $RE ]] || usage "Invalid option: '$T3_PORTS'"
HTTP_PORT=${BASH_REMATCH[2]}
HTTPS_PORT=${BASH_REMATCH[3]}

HTTP_OPTIONS=
[ -n "$HTTP_PORT" ] && HTTP_OPTIONS="$HTTP_OPTIONS --publish $HTTP_PORT:80"
[ -n "$HTTPS_PORT" ] && HTTP_OPTIONS="$HTTP_OPTIONS --publish $HTTPS_PORT:443"

# Split into private key file and certificate file
RE='^((.+),(.+))?$'
[[ "$T3_CERTFILES" =~ $RE ]] || usage "Invalid option: '$T3_CERTFILES'"
KEY_FILE=${BASH_REMATCH[2]}
CERT_FILE=${BASH_REMATCH[3]}

# Volume names and working directories
ROOT_MP=
if test_path "$T3_ROOT"; then
    ROOT_MP="$T3_ROOT"
    T3_ROOT=$($BASENAME "$T3_ROOT")
fi

DB_DATA_MP=
if test_path "$T3_DB_DATA"; then
    DB_DATA_MP="$T3_DB_DATA"
    T3_DB_DATA=$($BASENAME "$T3_DB_DATA")
fi

# Initialize container environment variables, keep 'T3_' prefix
RE='^(T3_('$RE_CONT_ENV'))=(.*)$'

while read -r ENV_VAR; do
    if [[ "$ENV_VAR" =~ $RE ]]; then
        ENV_OPTIONS="$ENV_OPTIONS \
            --env ${BASH_REMATCH[1]}=${BASH_REMATCH[3]}"
    fi
done <<< "$($PRINTENV)"

# Database type-specific settings
T3_DB_TYPE=$(autocomplete "$T3_DB_TYPE" sqlite mariadb postgresql)
T3_DB_DATA=${T3_DB_DATA:-typo3-data}

ENV_OPTIONS="$ENV_OPTIONS \
    --env T3_DB_TYPE=${T3_DB_TYPE:-sqlite}"

case "$T3_DB_TYPE" in
    mariadb)
        DB_CONTAINER_PORT=3306
        ;;

    postgresql)
        DB_CONTAINER_PORT=5432
        ;;
esac

case "$T3_DB_TYPE" in
    mariadb|postgresql)
        T3_DB_PORT=${T3_DB_PORT:-127.0.0.1:$DB_CONTAINER_PORT}
        DB_PORT_OPTION="--publish $T3_DB_PORT:$DB_CONTAINER_PORT"
        ENV_OPTIONS="$ENV_OPTIONS \
            --env T3_DB_NAME=${T3_DB_NAME:-t3} \
            --env T3_DB_USER=${T3_DB_USER:-t3} \
            --env T3_DB_PW=${T3_DB_PW:-t3} \
            --env T3_DB_ROOT_PW=${T3_DB_ROOT_PW:-toor}"
        ;;

    sqlite|'')
        ! [[ "$T3_TAG" =~ ^8 ]] || usage "TYPO3 '$T3_TAG' does not support SQLite"
        T3_DB_PORT=
        DB_PORT_OPTION=
        ;;

    *)
        usage "Unknown database type: '$T3_DB_TYPE'"
        ;;
esac


# --------------------------------------------------------------------------

# Execute command

case "$CMD" in

    run)
        # Verify that the container does not exist yet
        test_container "$T3_NAME" && \
            err_exit "Cannot run container '$T3_NAME': it already exists"$' ***\n*** '"To remove it, enter '$0 stop -e '$T3_ENGINE' -n '$T3_NAME' --rm'"

        # Roll back if command terminates prematurely
        trap "echo $'\n*** Command failed or interrupted, rolling back ***'; $0 stop -e '$T3_ENGINE' -n '$T3_NAME' --rm; exit 1" EXIT
        set -e

        # Update image if requested
        REPO=$T3_IMAGE${T3_TAG:+:$T3_TAG}
        if [ -n "$T3_PULL" ]; then
            echo '*** '"Pulling image '$REPO'"' ***'
            run_engine pull $REPO
        fi

        # Create the TYPO3 container
        echo '*** '"Creating container '$T3_NAME'"' ***'
        run_engine create \
            --name "$T3_NAME" \
            --hostname "$T3_HOSTNAME" \
            --ulimit $FILE_LIMIT \
            --volume "$T3_ROOT:$T3_ROOTDIR" \
            --volume "$T3_DB_DATA:$T3_DATADIR" \
            $HTTP_OPTIONS \
            $DB_VOL_OPTION \
            $DB_PORT_OPTION \
            $ENV_OPTIONS \
            "$@" \
            $REPO

        # Copy certificate files, if any
        if [ -n "$T3_CERTFILES" ]; then
            run_engine cp "$KEY_FILE" "$T3_NAME":${CERT_BASENAME}.key
            run_engine cp "$CERT_FILE" "$T3_NAME":${CERT_BASENAME}.pem
        fi
        echo '*** '"Container '$T3_NAME' created"' ***'

        # Start the container
        run_engine start "$T3_NAME"
        echo '*** '"Container '$T3_NAME' started"' ***'

        # Eventually bind-mount container volumes in userspace
        mount_volume "$T3_ROOT" "$ROOT_MP" || true
        mount_volume "$T3_DB_DATA" "$DB_DATA_MP" || true

        trap - EXIT

        # Eventually show logs
        [ -n "$T3_LOGS" ] && exec_engine logs --follow $TIMESTAMPS_OPTION "$T3_NAME" || true
        ;;


    stop)
        echo '*** '"Stopping container '$T3_NAME'"' ***'

        # Collect volume names from container
        # Note: prior to Podman v1.4.3, the volume name was contained in property .Source, not .Name
        VOLNAMES=$($T3_ENGINE container inspect \
            --format='{{range .Mounts}}{{if eq .Destination "'$T3_ROOTDIR'" "'$T3_DATADIR'"}}{{printf "%s " .Name}}{{end}}{{end}}' \
            "$T3_NAME" 2>/dev/null)

        # Try to unmount whatever may be mounted at the mountpoint of each volume
        for VOLNAME in $VOLNAMES; do
            unmount_volume "$VOLNAME"
        done

        # Stop and eventually remove the container
        #stop_container "$T3_NAME"
        if run_engine kill --signal SIGINT "$T3_NAME" && run_engine stop --time 5 "$T3_NAME"; then
            echo '*** '"Container '$T3_NAME' stopped"' ***'
        fi

        # Remove the container(s) if so requested
        [ -n "$REMOVE_OPTION" ] && run_engine container rm "$T3_NAME"

        # Wait until the container was removed eventually
        $SLEEP 1
        $T3_ENGINE container inspect "$T3_NAME" &>/dev/null || echo '*** '"Container '$T3_NAME' removed"' ***'
        ;;


    logs)
        exec_engine logs $FOLLOW_OPTION $SINCE_OPTION $TAIL_OPTION $TIMESTAMPS_OPTION "$T3_NAME"
        ;;


    env)
        exec_engine exec "$T3_NAME" setenv $HOST_IP_ENV "$@"
        ;;


    composer)
        exec_engine exec "$T3_NAME" composer "$@"
        ;;


    shell)
        exec_engine exec -it "$T3_NAME" /bin/bash "$@"
        ;;


    mount)
        [ $# -gt 0 ] || usage 'A working directory is required'
        for MP in "$@"; do
            mount_volume "$($BASENAME "$MP")" "$MP" || \
                err_exit "Not a working directory, or already mounted: '$1'"
        done
        ;;


    unmount)
        [ $# -gt 0 ] || usage 'A working directory is required'
        for MP in "$@"; do
            unmount_workdir "$($BASENAME "$MP")" "$MP" || \
                err_exit "Unable to unmount working directory '$MP'"
        done
        ;;

    *)
        usage "Unknown or ambiguous command: '$CMD'"
        ;;
esac
